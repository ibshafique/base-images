#!/usr/bin/env bash
# Cross-Platform Build Runner
# Resolves module build scripts and executes them with proper environment
#
# Usage:
#   ./run <module> [targets...] [options]
#   ./run scratch-plus build -Parch=amd64
#   ./run scratch-plus build test --load
#   ./run --doctor
#   ./run --help

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

RUNNER_VERSION="1.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Image search paths (ordered by priority)
IMAGE_SEARCH_PATHS=(
    "images/base"
    "images/demo"
    "images/templates"
)

# Required tools for basic operation
REQUIRED_TOOLS=(docker jq)

# Optional tools (parallel arrays for bash 3.2 compatibility â€” no associative arrays)
OPTIONAL_TOOL_NAMES=(cosign trivy grype conftest envsubst)
OPTIONAL_TOOL_DESCS=(
    "Image signing (Sigstore)"
    "Vulnerability scanning"
    "Alternative vulnerability scanner"
    "OPA policy testing"
    "Template rendering"
)

# ============================================================================
# Color Output
# ============================================================================

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

_color_enabled() {
    [[ -t 1 ]] && [[ -z "${NO_COLOR:-}" ]]
}

_info() {
    if _color_enabled; then
        echo -e "${BLUE}INFO${NC} $*"
    else
        echo "INFO $*"
    fi
}

_success() {
    if _color_enabled; then
        echo -e "${GREEN}DONE${NC} $*"
    else
        echo "DONE $*"
    fi
}

_warn() {
    if _color_enabled; then
        echo -e "${YELLOW}WARN${NC} $*" >&2
    else
        echo "WARN $*" >&2
    fi
}

_error() {
    if _color_enabled; then
        echo -e "${RED}ERROR${NC} $*" >&2
    else
        echo "ERROR $*" >&2
    fi
}

# ============================================================================
# Script Resolution
# ============================================================================

# Resolve module name to build.sh path
resolve_module() {
    local module="$1"

    # Direct path to build.sh
    if [[ -f "$module" ]]; then
        echo "$(cd "$(dirname "$module")" && pwd)/$(basename "$module")"
        return 0
    fi

    # Direct path to directory containing build.sh
    if [[ -d "$module" ]] && [[ -f "$module/build.sh" ]]; then
        echo "$(cd "$module" && pwd)/build.sh"
        return 0
    fi

    # Search in known paths
    for search_path in "${IMAGE_SEARCH_PATHS[@]}"; do
        local full_path="${SCRIPT_DIR}/${search_path}/${module}"
        if [[ -d "$full_path" ]] && [[ -f "$full_path/build.sh" ]]; then
            echo "${full_path}/build.sh"
            return 0
        fi
    done

    return 1
}

# List all available modules
list_modules() {
    echo "Available modules:"
    for search_path in "${IMAGE_SEARCH_PATHS[@]}"; do
        local full_path="${SCRIPT_DIR}/${search_path}"
        if [[ -d "$full_path" ]]; then
            for dir in "$full_path"/*/; do
                if [[ -f "${dir}build.sh" ]]; then
                    local module_name
                    module_name="$(basename "$dir")"
                    local category
                    category="$(basename "$search_path")"
                    printf "  %-20s (%s)\n" "$module_name" "$category"
                fi
            done
        fi
    done
}

# ============================================================================
# Doctor Command
# ============================================================================

run_doctor() {
    echo ""
    if _color_enabled; then
        echo -e "${BOLD}Base Images - Environment Check${NC}"
    else
        echo "Base Images - Environment Check"
    fi
    echo "================================"
    echo ""

    local all_ok=true

    # Check Bash version
    local bash_version="${BASH_VERSION%%.*}"
    if [[ "$bash_version" -ge 4 ]]; then
        _success "Bash ${BASH_VERSION} (4+ required)"
    else
        _error "Bash ${BASH_VERSION} (4+ required)"
        [[ "$(uname)" == "Darwin" ]] && echo "  Install: brew install bash"
        all_ok=false
    fi

    # Check required tools
    echo ""
    echo "Required tools:"
    for tool in "${REQUIRED_TOOLS[@]}"; do
        if command -v "$tool" >/dev/null 2>&1; then
            local version
            version=$("$tool" --version 2>/dev/null | head -1 || echo "installed")
            _success "$tool ($version)"
        else
            _error "$tool (not found)"
            all_ok=false
        fi
    done

    # Check Docker Buildx
    if command -v docker >/dev/null 2>&1; then
        if docker buildx version >/dev/null 2>&1; then
            local bx_version
            bx_version=$(docker buildx version 2>/dev/null | head -1)
            _success "docker buildx ($bx_version)"
        else
            _error "docker buildx (not available)"
            all_ok=false
        fi
    fi

    # Check optional tools
    echo ""
    echo "Optional tools:"
    for i in "${!OPTIONAL_TOOL_NAMES[@]}"; do
        local tool="${OPTIONAL_TOOL_NAMES[$i]}"
        local desc="${OPTIONAL_TOOL_DESCS[$i]}"
        if command -v "$tool" >/dev/null 2>&1; then
            _success "$tool - $desc"
        else
            _warn "$tool - $desc (not installed)"
        fi
    done

    # Check platform
    echo ""
    echo "Platform:"
    _info "OS: $(uname -s) $(uname -r)"
    _info "Arch: $(uname -m)"

    if [[ "$(uname -s)" == "Darwin" ]]; then
        if docker info >/dev/null 2>&1; then
            _success "Docker Desktop is running"
        else
            _error "Docker Desktop is not running"
            all_ok=false
        fi
    fi

    # Available modules
    echo ""
    list_modules

    echo ""
    if [[ "$all_ok" == "true" ]]; then
        _success "All checks passed!"
        return 0
    else
        _error "Some checks failed. Install missing tools and try again."
        return 1
    fi
}

# ============================================================================
# Help
# ============================================================================

show_help() {
    cat <<EOF
Base Images Build Runner v${RUNNER_VERSION}

Usage:
  ./run <module> [targets...] [options]
  ./run <command>

Commands:
  --doctor          Check environment and dependencies
  --list            List available modules
  --help            Show this help message

Module Targets:
  clean             Remove build artifacts
  build             Build the image
  test              Run tests (depends on build)
  scan              Scan for vulnerabilities
  sign              Sign image with Cosign

Options:
  -P<name>=<value>  Set parameter (e.g., -Parch=amd64)
  --load            Load image to Docker after build
  --push            Push image to registry
  --debug           Enable debug output
  --no-color        Disable colored output

Examples:
  ./run scratch-plus build                    # Build scratch-plus
  ./run scratch-plus build test --load        # Build, load to Docker, test
  ./run scratch-plus build -Parch=arm64       # Build for ARM64
  ./run distroless-static scan                # Scan distroless-static
  ./run wolfi-micro clean build test --debug  # Full rebuild with debug
  ./run --doctor                              # Check environment

EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
    # No arguments
    if [[ $# -eq 0 ]]; then
        show_help
        exit 0
    fi

    local first_arg="$1"

    # Handle commands
    case "$first_arg" in
        --doctor)
            run_doctor
            exit $?
            ;;
        --list)
            list_modules
            exit 0
            ;;
        --help|-h)
            show_help
            exit 0
            ;;
        --version|-v)
            echo "Base Images Build Runner v${RUNNER_VERSION}"
            exit 0
            ;;
        --*)
            _error "Unknown command: $first_arg"
            _info "Use --help for usage information"
            exit 1
            ;;
    esac

    # First arg is a module name
    local module="$first_arg"
    shift

    # Resolve module to build script
    local build_script
    if ! build_script=$(resolve_module "$module"); then
        _error "Module not found: $module"
        echo ""
        list_modules
        exit 1
    fi

    if [[ ! -x "$build_script" ]]; then
        _warn "Build script is not executable, fixing: $build_script"
        chmod +x "$build_script"
    fi

    _info "Running: $(basename "$(dirname "$build_script")") -> $(basename "$build_script")"

    # Execute the build script with remaining arguments
    exec "$build_script" "$@"
}

main "$@"
